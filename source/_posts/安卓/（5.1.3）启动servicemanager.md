---
title: 启动Servicemanager
categories:
- [Android,Framework内核解析,IPC Binder机制]
---

# 启动ServiceManager

## 1.启动ServiceManager进程

ServiceManager是由init进程通过解析init.rc文件而创建的，其所对应的可执行程序servicemanager，所对应的源文件是service\_manager.c，进程名为servicemanager。

```c
// system/core/rootdir/init.rc
// 114
on init
    // 395
    start servicemanager
```

启动ServiceManager的入口函数是`service_manager.c`中的main()方法。
解析文件 `frameworks/native/cmds/servicemanager/servicemanager.rc` 执行 servicemanager

```c
service servicemanager /system/bin/servicemanager
    class core animation
```

通过 Android.bp 文件可知，servicemanager 的源码是 `main.cpp`

```c
// frameworks/native/cmds/servicemanager/Android.bp
// 32
cc_binary {
    name: "servicemanager",
    defaults: ["servicemanager_defaults"],
    init_rc: ["servicemanager.rc"],
    srcs: ["main.cpp"],
}
```

![64706269.png](https://lingzhiwen.github.io/images/servicemanager_files/64706269.png)

ServiceManager 启动的时候主要做了三件事：

1.  打开binder驱动
2.  成为上下文的管理者，这样所有的进程都可以获取到它
3.  循环等待服务的注册

## <2.main@main.cpp>

```c
// frameworks/native/cmds/servicemanager/main.cpp
int main(int argc, char** argv) {
    const char* driver = argc == 2 ? argv[1] : "/dev/binder";
    // 1.打开binder驱动
    sp<ProcessState> ps = ProcessState::initWithDriver(driver);
    ... ...
    // 2.成为上下文的管理者，这样所有的进程都可以获取到它
    ps->becomeContextManager(nullptr, nullptr);
    ... ...
    // 3.将binder回调设置到 looper中
    BinderCallback::setupTo(looper);
    // 4.循环处理服务的注册，例如AMS、WMS等的注册
    while(true) {
        looper->pollAll(-1);
    }
    ... ...
}
```

### 2-1.ProcessState::initWithDriver--打开binder驱动

```c
// frameworks/native/libs/binder/ProcessState.cpp
sp<ProcessState> ProcessState::initWithDriver(const char* driver)
{
    // 初始化 ProcessState 对象，这个里面就会调用到binder_open方法，打开驱动
    gProcess = new ProcessState(driver);
}



ProcessState::ProcessState(const char *driver)
    : mDriverName(String8(driver))
    , mDriverFD(open_driver(driver))
    , ... ...
{
    ... ...
    if (mDriverFD >= 0) {
        // 调用mmap，实现内存映射，最终调用到内核的 binder_mmap 方法
        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        ... ...
    }
    ... ...
}
```

### 2-2. ps->becomeContextManager

成为上下文的管理者，这样所有的进程都可以获取到它。

```c
bool ProcessState::becomeContextManager(context_check_func checkFunc, void* userData)
{
    ... ...
    // 通过ioctl，传递 BINDER_SET_CONTEXT_MGR_EXT 指令
    int result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &obj);
    ... ...
}
```

上面方法通过调用ioctl，实际就会进入binder\_ioctl，然后执行命令 BINDER\_SET\_CONTEXT\_MGR\_EXT。

```c
static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    ... ...
    switch (cmd) {
    ... ...
    case BINDER_SET_CONTEXT_MGR_EXT: {
        ... ...
        ret = binder_ioctl_set_ctx_mgr(filp, &fbo);
        ... ...
    }
    ... ...
}
```

binder\_ioctl\_set\_ctx\_mgr 方法主要做了两件事：

1.  为servicemanager 绑定 uid，也就是我们在binder直播课中说的，binder会为服务绑定uid，所以比传统的IPC机制更安全。
2.  为 servicemanager 创建 binder\_node 结构体。

#### 2-2-1.什么是binder\_node结构体呢？

binder\_node 结构体就是 servicemanager 在binder 驱动层的binder 实体对象。
我们可以根据下图理解：
![8a7025a8-cb1a-4227-93c4-82d5faf9e74f.jpeg](https://lingzhiwen.github.io/images/servicemanager_files/8a7025a8-cb1a-4227-93c4-82d5faf9e74f.jpeg)
所有服务端在用户进程都有个binder实体，在驱动层也会对应有一个binder实体，这样binder驱动和服务端就会一一对应。
然后binder驱动根据binder实体会对应生成一个binder的代理对象，这样binder驱动中，binder的实体和代理对象也一一对应了。
最后客户端就可以根据这个binder代理对象，最终找到对应的binder实体对象。

### 2-3.BinderCallback::setupTo(looper)--循环等待服务注册

```c
// frameworks/native/cmds/servicemanager/main.cpp
class BinderCallback : public LooperCallback {
public:
    static sp<BinderCallback> setupTo(const sp<Looper>& looper) {
        ... ...
        // 写入准备执行的命令：BC_ENTER_LOOPER
        IPCThreadState::self()->setupPolling(&binder_fd);
        ... ...
        // 执行 BC_ENTER_LOOPER，并进入等待
        IPCThreadState::self()->flushCommands();
        ... ...
    }
};
```

#### 2-3-1. IPCThreadState::self()->setupPolling

```c
// frameworks/native/libs/binder/IPCThreadState.cpp
int IPCThreadState::setupPolling(int* fd)
{
    ... ...
    // 写入准备执行的命令：BC_ENTER_LOOPER
    mOut.writeInt32(BC_ENTER_LOOPER);
... ...
}
```

#### 2-3-2.IPCThreadState::self()->flushCommands

```c
void IPCThreadState::flushCommands()
{
    ... ...
    talkWithDriver(false);
    ... ...
}
```

talkWithDriver 方法就会执行 ioctl。

```c
status_t IPCThreadState::talkWithDriver(bool doReceive)
{
    ... ...
    // 执行 ioctl
    if (ioctl(mProcess->mDriverFD, BINDER_WRITE_READ, &bwr) >= 0)
    ... ...
}
```

进入binder驱动后，接着就会执行 binder\_thread\_write 和 binder\_thread\_read 方法。
binder\_thread\_write 主要是设置 状态。

```c
static int binder_thread_write(struct binder_proc *proc,
            struct binder_thread *thread,
            binder_uintptr_t binder_buffer, size_t size,
            binder_size_t *consumed)
{
    switch (cmd) {
        ... ...
        case BC_ENTER_LOOPER:
            // 设置转态为 BINDER_LOOPER_STATE_ENTERED，准备进入循环
            thread->looper |= BINDER_LOOPER_STATE_ENTERED;
            break;
    ... ...
}
```

binder\_thread\_read 则让servicemanager 进入等待。

```c
static int binder_thread_read(struct binder_proc *proc,
                  struct binder_thread *thread,
                  binder_uintptr_t binder_buffer, size_t size,
                  binder_size_t *consumed, int non_block)
{
    ... ...
    // 阻塞，等待其他服务注册
    ret = binder_wait_for_work(thread, wait_for_proc_work);
    ... ...
}
```

接下来就是等待客户端来注册，当然这儿所说的客户端就是 AMS、WMS等服务，相对于servicemanager来说，一切皆是客户端。
